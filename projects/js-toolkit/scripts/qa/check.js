/**
 * SPDX-FileCopyrightText: Â© 2020 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/* eslint-disable no-console */

const {createHash} = require('crypto');
const fs = require('fs');
const path = require('path');

const {qaDir} = require('./resources');
const {logStep} = require('./util');

const IGNORED_ITEMS = ['.liferay.json', 'node_modules', 'yarn.lock'];

function check(projectDirName) {
	const expectedDir = path.join(qaDir, 'expected', projectDirName);

	if (!fs.existsSync(expectedDir)) {
		return;
	}

	logStep(`CHECK: ${projectDirName}`);

	const actualDir = path.join(qaDir, projectDirName);

	const failed = diff(expectedDir, actualDir, {});

	if (failed) {
		console.log('');
		console.log('Legend:');
		console.log('  + Unexpected file/dir generated by the build');
		console.log('  - Expected file/dir missing from build');
		console.log('  * File contents in build differ from the expected');
		console.log('');
		console.log('Project check failed.');

		process.exit(1);
	}
}

function diff(expectedDir, actualDir, tokens) {
	let somethingChanged = false;

	if (!fs.existsSync(actualDir)) {
		console.log('-', actualDir);

		return true;
	}

	const expectedItems = fs.readdirSync(expectedDir);
	const actualItems = fs
		.readdirSync(actualDir)
		.filter((item) => !IGNORED_ITEMS.includes(item));

	for (const actualItem of actualItems) {
		if (!expectedItems.includes(actualItem)) {
			somethingChanged = true;
			console.log('+', path.join(actualDir, actualItem));
		}
	}

	for (const expectedItem of expectedItems) {
		const actualFile = path.resolve(actualDir, expectedItem);
		const expectedFile = path.resolve(expectedDir, expectedItem);

		if (fs.statSync(expectedFile).isDirectory()) {
			const somethingInsideChanged = diff(
				expectedFile,
				actualFile,
				tokens
			);

			somethingChanged = somethingChanged || somethingInsideChanged;
		}
		else if (!actualItems.includes(expectedItem)) {
			somethingChanged = true;
			console.log('-', path.join(actualDir, expectedItem));
		}
		else {
			const expectedContent = readExpected(expectedFile, tokens);
			const actualContent = fs.readFileSync(actualFile);

			const expectedHash = createHash('sha256')
				.update(expectedContent)
				.digest('hex');
			const actualHash = createHash('sha256')
				.update(actualContent)
				.digest('hex');

			if (expectedHash !== actualHash) {
				somethingChanged = true;
				console.log('*', path.join(actualDir, expectedItem));
			}

			/*

			console.log('<<<<<<<<<<<<<<<<<<');
			console.log(expectedContent);
			console.log('==================');
			console.log(actualContent.toString());
			console.log('>>>>>>>>>>>>>>>>>>');

			*/
		}
	}

	return somethingChanged;
}

function readExpected(file, tokens) {
	const tokenized = fs.existsSync(`${file}.TOKENIZE`);

	if (tokenized) {
		file += '.TOKENIZE';
	}

	let content = fs.readFileSync(file).toString();

	if (!tokenized) {
		return content;
	}

	Object.entries(tokens).forEach(([key, value]) => {
		content = content.replace(new RegExp(`{{${key}}}`, 'g'), value);
	});

	return content;
}

module.exports = check;
